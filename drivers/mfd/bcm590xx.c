// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * Broadcom BCM590xx PMU
 *
 * Copyright 2014 Linaro Limited
 * Author: Matt Porter <mporter@linaro.org>
 */

#include <linux/err.h>
#include <linux/i2c.h>
#include <linux/init.h>
#include <linux/mfd/bcm590xx.h>
#include <linux/mfd/core.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/of.h>
#include <linux/regmap.h>
#include <linux/slab.h>

/* Under primary I2C address: */
#define BCM590XX_REG_PMUID		0x1e
#define BCM590XX_PMUID_BCM59054		0x54
#define BCM590XX_PMUID_BCM59056		0x56

#define BCM590XX_REG_PMUREV		0x1f
#define BCM590XX_PMUREV_DIG_MASK	0xF
#define BCM590XX_PMUREV_DIG_SHIFT	0
#define BCM590XX_PMUREV_ANA_MASK	0xF0
#define BCM590XX_PMUREV_ANA_SHIFT	4

#define BCM590XX_REG_IRQ1		0x20
#define BCM590XX_REG_IRQ1_MASK		0x30

static const struct mfd_cell bcm59054_devs[] = {
	{ .name = "bcm590xx-vregs", },
	{
		.name = "bcm590xx-ponkey",
		.of_compatible = "brcm,bcm59054-ponkey",
	}
};

static const struct mfd_cell bcm59056_devs[] = {
	{ .name = "bcm590xx-vregs", },
	{
		.name = "bcm590xx-ponkey",
		.of_compatible = "brcm,bcm59056-ponkey",
	}
};


static bool bcm590xx_volatile_pri(struct device *dev, unsigned int reg)
{
	/*
	 * IRQ registers are clear-on-read, make sure we don't cache them
	 * so that they get read/cleared correctly
	 */
	return (reg >= BCM590XX_REG_IRQ1 &&
		reg <= (BCM590XX_REG_IRQ1 + 15));
}

static const struct regmap_config bcm590xx_regmap_config_pri = {
	.reg_bits	= 8,
	.val_bits	= 8,
	.max_register	= BCM590XX_MAX_REGISTER_PRI,
	.volatile_reg	= bcm590xx_volatile_pri,
	.cache_type	= REGCACHE_MAPLE,
};

static const struct regmap_config bcm590xx_regmap_config_sec = {
	.reg_bits	= 8,
	.val_bits	= 8,
	.max_register	= BCM590XX_MAX_REGISTER_SEC,
	.cache_type	= REGCACHE_MAPLE,
};

/** Interrupt handling **/

/*
 * IRQs in the MFD header are ordered exactly as they should be in hardware.
 * We use a macro to simplify defining IRQ regs:
 */
#define BCM590XX_REGMAP_IRQ_REG(id)	REGMAP_IRQ_REG_LINE(id, 8)

/* BCM59054 IRQs */

static const struct regmap_irq bcm59054_regmap_irqs[] = {
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_USBINS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_USBRM),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_BATINS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_BATRM),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MBC_CV_LOOP),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MBC_CV_TMR_EXP),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_EOC),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RESUME_VBUS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MBTEMPLOW),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MBTEMPHIGH),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_USBOV),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MBOV),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CHGERRDIS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MBOV_DIS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_USBOV_DIS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MBC_TF),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CHG_HW_TTR_EXP),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CHG_HW_TCH_EXP),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CHG_SW_TMR_EXP),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CHG_TCH_1MIN_BF_EXP),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_USB_PORT_DIS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_USB_CC_REDUCE),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_VBUSLOWBND),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_UBPD_CHG_F),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_VBUS_VALID_F),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_OTG_SESS_VALID_F),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_VB_SESS_END_F),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_ID_RM),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_VBUS_VALID_R),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_VA_SESS_VALID_R),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_VB_SESS_END_R),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_ID_INS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_IDCHG),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RIC_C_TO_FLOAT),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CHGDET_LATCH),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CHGDET_TO),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_ADP_CHANGE),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_ADP_SNS_END),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_ADP_PROB),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_ADP_PRB_ERR),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_POK_PRESSED),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_POK_RELEASED),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_POK_WAKEUP),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_POK_BIT_VLD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_POK_RESTART),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_POK_T1),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_POK_T2),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_POK_T3),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_I2C_RESTART),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_GBAT_PLUG_IN),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_SMPL_INT),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_AUX_INS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_AUX_RM),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_XTAL_FAILURE),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MBWV_R_10S_WAIT),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MBWV_F),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RTC_ALARM),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RTC_SEC),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RTC_MIN),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RTCADJ),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_FGC),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_BBLOW),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_DIE_OT_R),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_DIE_OT_F),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RTM_DATA_RDY),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RTM_IN_CON_MEAS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RTM_UPPER),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RTM_IGNORE),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RTM_OVERRIDDEN),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_AUD_HSAB_SHCKT),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_AUD_IHFD_SHCKT),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_POK_NOP),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MIPI_LEN_ERR),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MIPI_RCV_ERR),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MIPI_BUSQ_RESP),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MIPI_BUSQ_POS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MIPI_EOT),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MIPI_XMT_END),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MIPI_INT_POS),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_LOWBAT),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CSROVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_VSROVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MSROVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_SDSR1OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_SDSR2OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_IOSR1OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_IOSR2OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RESERVED),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RFLDO_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_AUDLDO_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_USBLDO_OVR),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_SDXLDO_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MICLDO_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_SIMLDO1_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_SIMLDO2_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MMCLDO1_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CAMLDO1_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CAMLDO2_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_VIBLDO_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_SDLDO_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_GPLDO1_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_GPLDO2_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_GPLDO3_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_RFLDO_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_AUDLDO_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_USBLDO_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_SDXLDO_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MICLDO_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_SIMLDO1_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_SIMLDO2_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MMCLDO1_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_MMCLDO2_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CAMLDO1_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_CAMLDO2_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_VIBLDO_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_SDLDO_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_GPLDO1_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_GPLDO2_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_GPLDO3_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_TCXLDO_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_LVLDO1_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_LVLDO2_OVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_TCXLDO_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_LVLDO1_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_LVLDO2_SHD),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_VBOVRV),
	BCM590XX_REGMAP_IRQ_REG(BCM59054_IRQ_VBOVRI),
};

static const struct regmap_irq_chip bcm59054_irq_chip = {
	.name = "bcm59054-irq",
	.irqs = bcm59054_regmap_irqs,
	.num_irqs = BCM59054_IRQ_MAX,
	.num_regs = 16,
	.status_base = BCM590XX_REG_IRQ1,
	.mask_base = BCM590XX_REG_IRQ1_MASK,
	.clear_on_unmask = true,
};

/* BCM59056 IRQs */

static const struct regmap_irq bcm59056_regmap_irqs[] = {
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_RTC_ALARM),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_RTC_SEC),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_RTC_MIN),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_RTCADJ),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_BATINS),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_BATRM),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_GBAT_PLUG_IN),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_SMPL_INT),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_USBINS),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_USBRM),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_USBOV),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_EOC),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_RESUME_VBUS),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_CHG_HW_TTR_EXP),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_CHG_HW_TCH_EXP),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_CHG_SW_TMR_EXP),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_CHGDET_LATCH),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_CHGDET_TO),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_MBTEMPLOW),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_MBTEMPHIGH),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_MBOV),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_MBOV_DIS),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_USBOV_DIS),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_CHGERRDIS),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_VBUS_1V5_R),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_VBUS_4V5_R),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_VBUS_1V5_F),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_VBUS_4V5_F),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_MBWV_R_10S_WAIT),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_BBLOW),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_LOWBAT),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_VERYLOWBAT),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_RTM_DATA_RDY),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_RTM_IN_CON_MEAS),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_RTM_UPPER),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_RTM_IGNORE),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_RTM_OVERRIDDEN),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_AUD_HSAB_SHCKT),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_AUD_IHFD_SHCKT),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_MBC_TF),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_CSROVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_IOSROVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_SDSROVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_ASROVRI),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_UBPD_CHG_F),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_ACD_INS),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_ACD_RM),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_PONKEYB_HOLD),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_PONKEYB_F),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_PONKEYB_R),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_PONKEYB_OFFHOLD),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_PONKEYB_RESTART),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_IDCHG),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_JIG_USB_INS),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_UART_INS),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_ID_INS),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_ID_RM),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_ADP_CHANGE),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_ADP_SNS_END),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_SESSION_END_VLD),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_SESSION_END_INVLD),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_VBUS_OVERCURRENT),
	BCM590XX_REGMAP_IRQ_REG(BCM59056_IRQ_FGC),
};

static const struct regmap_irq_chip bcm59056_irq_chip = {
	.name = "bcm59056-irq",
	.irqs = bcm59056_regmap_irqs,
	.num_irqs = BCM59056_IRQ_MAX,
	.num_regs = 16,
	.status_base = BCM590XX_REG_IRQ1,
	.mask_base = BCM590XX_REG_IRQ1_MASK,
	.clear_on_unmask = true,
};

static int bcm590xx_irq_init(struct bcm590xx *bcm590xx)
{
	const struct regmap_irq_chip *irq_chip;
	int ret;

	if (!bcm590xx->irq) {
		dev_err(bcm590xx->dev, "No IRQ configured\n");
		return -EINVAL;
	}

	switch (bcm590xx->dev_type) {
	case BCM59054_TYPE:
		irq_chip = &bcm59054_irq_chip;
		break;
	case BCM59056_TYPE:
		irq_chip = &bcm59056_irq_chip;
		break;
	default:
		dev_err(bcm590xx->dev,
			"Unknown device type, this is a driver bug!\n");
		return -EINVAL;
	}

	ret = devm_regmap_add_irq_chip(bcm590xx->dev, bcm590xx->regmap_pri,
			bcm590xx->irq, IRQF_TRIGGER_FALLING, 0,
			irq_chip, &bcm590xx->irq_data);
	if (ret) {
		dev_err(bcm590xx->dev, "Failed to reguest IRQ %d: %d\n",
			bcm590xx->irq, ret);
		return ret;
	}

	return 0;
}

/** Chip version parsing **/

/* Map device_type enum value to model name string */
static const char * const bcm590xx_names[BCM590XX_TYPE_MAX] = {
	[BCM59054_TYPE] = "BCM59054",
	[BCM59056_TYPE] = "BCM59056",
};

/*
 * Parse the version from version registers and make sure it matches
 * the device type passed to the compatible.
 */
static int bcm590xx_parse_version(struct bcm590xx *bcm590xx)
{
	unsigned int id, rev;
	int ret;

	/* Get PMU ID and verify that it matches compatible */
	ret = regmap_read(bcm590xx->regmap_pri, BCM590XX_REG_PMUID, &id);
	if (ret) {
		dev_err(bcm590xx->dev, "failed to read PMU ID: %d\n", ret);
		return ret;
	}

	switch (bcm590xx->dev_type) {
	case BCM59054_TYPE:
		if (id != BCM590XX_PMUID_BCM59054) {
			dev_err(bcm590xx->dev,
				"Incorrect ID for BCM59054: expected %x, got %x. Check your DT compatible.\n",
				BCM590XX_PMUID_BCM59054, id);
			return -EINVAL;
		}
		break;
	case BCM59056_TYPE:
		if (id != BCM590XX_PMUID_BCM59056) {
			dev_err(bcm590xx->dev,
				"Incorrect ID for BCM59056: expected %x, got %x. Check your DT compatible.\n",
				BCM590XX_PMUID_BCM59056, id);
			return -EINVAL;
		}
		break;
	default:
		dev_err(bcm590xx->dev,
			"Unknown device type, this is a driver bug!\n");
		return -EINVAL;
	}

	/* Get PMU revision and store it in the info struct */
	ret = regmap_read(bcm590xx->regmap_pri, BCM590XX_REG_PMUREV, &rev);
	if (ret) {
		dev_err(bcm590xx->dev, "failed to read PMU revision: %d\n",
			ret);
		return ret;
	}

	bcm590xx->rev_dig = (rev & BCM590XX_PMUREV_DIG_MASK)
				 >> BCM590XX_PMUREV_DIG_SHIFT;

	bcm590xx->rev_ana = (rev & BCM590XX_PMUREV_ANA_MASK)
				 >> BCM590XX_PMUREV_ANA_SHIFT;

	dev_info(bcm590xx->dev, "PMU ID 0x%x (%s), revision: dig %d ana %d",
		 id, bcm590xx_names[bcm590xx->dev_type],
		 bcm590xx->rev_dig, bcm590xx->rev_ana);

	return 0;
}

static int bcm590xx_i2c_probe(struct i2c_client *i2c_pri)
{
	struct bcm590xx *bcm590xx;
	const struct mfd_cell *cells;
	int ret, num_cells;

	bcm590xx = devm_kzalloc(&i2c_pri->dev, sizeof(*bcm590xx), GFP_KERNEL);
	if (!bcm590xx)
		return -ENOMEM;

	i2c_set_clientdata(i2c_pri, bcm590xx);
	bcm590xx->dev = &i2c_pri->dev;
	bcm590xx->irq = i2c_pri->irq;
	bcm590xx->i2c_pri = i2c_pri;

	bcm590xx->dev_type = (uintptr_t) of_device_get_match_data(bcm590xx->dev);

	bcm590xx->regmap_pri = devm_regmap_init_i2c(i2c_pri,
						 &bcm590xx_regmap_config_pri);
	if (IS_ERR(bcm590xx->regmap_pri)) {
		ret = PTR_ERR(bcm590xx->regmap_pri);
		dev_err(&i2c_pri->dev, "primary regmap init failed: %d\n", ret);
		return ret;
	}

	/* Secondary I2C slave address is the base address with A(2) asserted */
	bcm590xx->i2c_sec = i2c_new_dummy_device(i2c_pri->adapter,
					  i2c_pri->addr | BIT(2));
	if (IS_ERR(bcm590xx->i2c_sec)) {
		dev_err(&i2c_pri->dev, "failed to add secondary I2C device\n");
		return PTR_ERR(bcm590xx->i2c_sec);
	}
	i2c_set_clientdata(bcm590xx->i2c_sec, bcm590xx);

	bcm590xx->regmap_sec = devm_regmap_init_i2c(bcm590xx->i2c_sec,
						&bcm590xx_regmap_config_sec);
	if (IS_ERR(bcm590xx->regmap_sec)) {
		ret = PTR_ERR(bcm590xx->regmap_sec);
		dev_err(&bcm590xx->i2c_sec->dev,
			"secondary regmap init failed: %d\n", ret);
		goto err;
	}

	ret = bcm590xx_parse_version(bcm590xx);
	if (ret)
		goto err;

	ret = bcm590xx_irq_init(bcm590xx);
	if (ret)
		goto err;

	switch (bcm590xx->dev_type) {
	case BCM59054_TYPE:
		cells = bcm59054_devs;
		num_cells = ARRAY_SIZE(bcm59054_devs);
		break;
	case BCM59056_TYPE:
		cells = bcm59056_devs;
		num_cells = ARRAY_SIZE(bcm59056_devs);
		break;
	default:
		ret = -EINVAL;
		goto err;
	};

	ret = devm_mfd_add_devices(&i2c_pri->dev, -1, cells, num_cells,
				   NULL, 0, NULL);
	if (ret < 0) {
		dev_err(&i2c_pri->dev, "failed to add sub-devices: %d\n", ret);
		goto err;
	}

	return 0;

err:
	i2c_unregister_device(bcm590xx->i2c_sec);
	return ret;
}

static const struct of_device_id bcm590xx_of_match[] = {
	{ .compatible = "brcm,bcm59054", .data = (void *)BCM59054_TYPE },
	{ .compatible = "brcm,bcm59056", .data = (void *)BCM59056_TYPE },
	{ }
};
MODULE_DEVICE_TABLE(of, bcm590xx_of_match);

static const struct i2c_device_id bcm590xx_i2c_id[] = {
	{ "bcm59056" },
	{ }
};
MODULE_DEVICE_TABLE(i2c, bcm590xx_i2c_id);

static struct i2c_driver bcm590xx_i2c_driver = {
	.driver = {
		   .name = "bcm590xx",
		   .of_match_table = bcm590xx_of_match,
	},
	.probe = bcm590xx_i2c_probe,
	.id_table = bcm590xx_i2c_id,
};
module_i2c_driver(bcm590xx_i2c_driver);

MODULE_AUTHOR("Matt Porter <mporter@linaro.org>");
MODULE_DESCRIPTION("BCM590xx multi-function driver");
MODULE_LICENSE("GPL v2");
